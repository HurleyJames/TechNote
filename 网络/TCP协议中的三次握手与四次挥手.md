## TCP协议中的三次握手与四次挥手

TCP的传输连接分为3个阶段：连接建立（**三次握手**）、数据传送和连接释放（**四次挥手**）。TCP传输连接的管理就是使传输连接的建立和释放都能正常地进行。

### 三次握手

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20160814211809136.jpeg)

* 准备工作：服务器必须准备好接受外来的连接。通常通过调用`socket`、`bind`和`listen`这三个函数来完成。这个过程叫做**被动打开**。

* 第一次握手：客户端通过调用connect发起**主动打开**。客户端向服务器发出连接请求的TCP报文段，其TCP首部中的同步比特SYN置为1，TCP首部中序号seq设置为x（TCP规定SYN报文段不能携带数据，但是要消耗一个序号），表明要传送数据时初始序列号是x。
* 第二次握手：服务器收到数据报后，从TCP数据报首部的**同步比特位SYN**为1可知这是建立连接的请求。服务器如果同意，就会发送会确认。在确认报文段中把**同步比特位SYN**设置为1，**确认比特位ACK**设置为1。因为TCP请求报文段中的序号是x，所以服务器在发送确认报文段中的确认比序号ack是x+1，同时把确认报文段中的序号seq设置为y，表示服务器发送数据的初始序列号为y。因为SYN=1，所以该报文段不携带任何数据。
* 第三次握手：客户端收到服务器端的报文段后，对服务器中的SYN进行确认。在确认报文段中把**确认比特位ACK**设置为1，然后把确认号ack设置为y+1，自身的序号seq设置为x+1。

------

上面的情况是**建立成功**的情况，下面还有几种出错返回的情况：

1. 客户端发送的建立连接的SYN报文丢失或者服务器回复的ACK报文丢失。客户端因为没有收到服务器的回复，会在等待6秒后重新发送一次，若无响应，则等待24s后再重新发送一次，总共等待75秒后还未收到响应就要返回错误。
2. 服务器回复的TCP报文中**复位标志RST置位1**，表示服务器主机没有在指定的端口上监听或接受该连接或服务器程序根本没有运行。
3. 客户端发送的SYN报文不可达。IP数据报中有一个生存时间，它每经过一个路由器都会减1，当它减到0时还没有到达目的地，就会发送一个**ICMP**错误。然后客户端会隔一段时间重发一次。

------

**Q**：为什么不可以把TCP连接的三次握手转化为两次握手？

**A**：因为假如从客户端发出的第一个连接请求报文段没有消失，而是在某个网络结点长时间滞留了，等到连接都释放后的某个时间才到达服务器，也就是说这是一个失效的报文段。但是当服务器收到此失效的连接请求报文段后，就会误认为这是客户端再次发出的一个连接请求，然后就会向客户端发送确认报文，同意建立连接。所以仅需这两次连接就建立连接的话就会出现错误，因为客户端并没有实际发出建立连接的请求（之前的请求已经失效）。而经过三次连接，就增加了一个确认的步骤，客户端和服务器就都可以确认TCP正确连接。

### 四次挥手

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20160814211924324.jpeg)

* 数据传输完毕后，通信双方都是可以释放连接的。首先调用`close`的一端称为**主动关闭**，另外一端就是**被动关闭**。

* 第一次挥手：假设客户端执行主动关闭，会向服务器端发出释放连接的报文段。终止比特FIN置为1，序号seq设置为u，并停止发送数据，主动关闭TCP连接，等待服务器的确认。因为TCP是全双工的，所以TCP连接上有两条数据通路，发送FIN的一端不能发送数据，但另一端还是可以继续发送数据。
* 第二次挥手：服务器端收到客户端的释放连接的报文段后会执行被动关闭，要对客户端的数据报进行确认，服务器端会发送一个确认的数据报，确认比特ACK设置为1，确认号为u+1，自身序号seq为v。此时TCP为半关闭状态，服务器依然可以向客户端发送数据。
* 第三次挥手：服务器端已经没有要发送给客户端的数据，那么服务器端也会调用close关闭套接字，服务器会发送一个FIN的TCP报文段，序号是w，这时服务器端不会再向客户端发送数据。
* 第四次挥手：客户端接受到最终的FIN的释放连接报文段后必须对报文段进行确认。在确认的报文段中，ACK=1，确认序号ack=w+1，自身序号为seq=u+1。

------

**Q**：为什么TCP是三次握手，而是四次挥手？

**A**：因为在三次握手中，服务器的SYN和ACK都是放在一个TCP报文段中向客户端发送的，而四次挥手中，服务器向客户端发送的ACK和FIN是在两个不同的TCP报文段中。因为服务器接收到客户端的FIN后，可能还有数据需要传输，所以就先发送ACK，待数据传输完之后再发送FIN断开连接。