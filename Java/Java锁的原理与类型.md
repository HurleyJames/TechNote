## Java锁的原理与类型

### 概述

为了**保证数据的一致性**，在多线程编程中我们会使用到锁，使得在某一个时间点，只有一个线程进入到临界区代码，用于保证临界区代码的安全。虽然不同的语言可能会提供不同的锁接口，但是底层调用的都会操作系统体用的锁。

### 本质

锁，本质上只是内存中的一个整型数，不同的数值表示不同的状态，拥有两种状态：空闲状态和上锁状态。对于加锁和解锁，操作系统是如何保证锁操作本身的原子性呢？我们可以把上锁的过程具体表示为：

1. 读内存表示锁的变量
2. 判断锁的状态
3. 如果已经加锁，就返回失败
4. 然后把锁设置为上锁状态
5. 返回成功

那什么情况下能让两个线程同时获取到锁？

1. 中断：假设线程A执行完第一步，发生中断，中断返回后，操作系统调度线程B，线程B加锁并枷锁成功，然后操作系统再调度线程A执行，线程A从第二步开始执行，加锁成功。
2. 多核：两个核同时获取到锁。

在硬件方面，CPU提供了原子操作、关中断、锁内存总线的机制。

### Java锁的种类和区别

* 公平锁/非公平锁
* 可重入锁
* 独享锁/共享锁
* 互斥锁/读写锁
* 乐观锁/悲观锁
* 分段锁
* 偏向锁/轻量级锁/重量级锁
* 自旋锁

#### 公平锁/非公平锁

**公平锁**是指多个线程按照申请锁的顺序来获取锁。

**非公平锁**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的会先获取锁。有可能会造成优先级反转或者饥饿现象（饥饿现象即当一个进程一直无法得到自己的资源而一直无法进行后续的操作（不一定是阻塞），我们称这个进程为饥饿）。

非公平锁的优点是吞吐量比公平锁要大。

`ReentrantLock`通过构造函数指定该锁是否是公平锁，默认是非公平锁。

`Synchronized`是一种非公平锁。

#### 可重入锁

**可重入锁**又叫递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。可重入锁的一个好处是可一定程度上避免死锁。

`ReentranLock`从名字看就是一个可重入锁。

`Synchronized`也是一个可重入锁。

```java
synchronized void setA() throws Exception {
    Thread.sleep(1000);
    setB();
}

synchronized void setB() throws Exception {
    Thread.sleep(1000);
}
```

如上代码所示，正因为`Synchronized`是可重入锁，所以以上代码才会执行`setB()`方法，否则如果不是可重入锁，`setB()`可能不会被当前线程执行，可能会造成死锁。

#### 独享锁/共享锁

**独享锁**是指该锁一次只能被一个线程所持有。

**共享锁**是指该锁可被多个线程持有。

`ReentranLock`是独享锁。

`ReadWriteLock`的读锁是共享锁，写锁是独享锁。因为读锁是共享锁可保持并发是非常高效的。

`Synchronized`是独享锁。

#### 互斥锁/读写锁

**互斥锁/读写锁**是独享锁/共享锁的具体表现。

在Java中的互斥锁就是`ReentranLock`。

在Java中的读写锁就是`ReadWriteLock`。

#### 乐观锁/悲观锁

乐观锁与悲观锁不是具体类型的锁，而是指看待并发同步的角度。

**悲观锁**认为对于同一个数据的并发操作，一定会发生修改。所以对于同一个数据的并发操作，悲观锁采取加锁的方式，它悲观地认为，不加锁的并发操作一定会出现问题。

**乐观锁**认为对于同一个数据的并发操作是不会发生修改的。所以在更新数据时，会不断重新地更新数据。它乐观地认为，不加锁的并发操作是没有问题的。

所以，<font color="red">悲观锁适合写操作，乐观锁适合读操作</font>，不加锁会带来大量的性能提升。

在Java中，悲观锁就是利用各种锁加锁，乐观锁就是无锁编程，常采用的是**CAS算法**，典型的例子是**原子类**，通过CAS自旋实现原子操作的更新。

#### 分段锁

**分段锁**是一种锁的设计，不是一种具体的锁，它的设计目的是细化锁的粒度，当操作不需要更新整个数组时，就仅仅针对数组中的一项进行加锁操作。

比如ConcurrentHashMap的并发实现就是通过分段锁的形式来实现高效的并发操作的。ConcurrentHashMap中的分段锁称为Segment，当put元素时，不是对整个Map进行枷锁，而是通过hashCode获取它的位置在哪一个分段中，然后对这个分段进行加锁。

#### 偏向锁/轻量级锁/重量级锁

这种锁专指`Synchronized`，是指锁的状态。

**偏向锁**是指如果一段同步代码一直被一个线程所访问，那么该线程就会自动获取锁，从而降低获取锁的代价。

**轻量级锁**是当一个锁是偏向锁的时候，被另一个线所访问，那么就会由偏向锁升级成为轻量级锁，其它线程就会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**是指当前锁为轻量级锁的时候，另一个线程虽然是自旋，但是自旋不会一直持续下去，当自旋超过一定次数的时候还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其它申请的线程进入阻塞，性能降低。

#### 自旋锁

在Java中自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，好处是减少线程上下文切换的消耗，缺点就是循环会消耗CPU。













